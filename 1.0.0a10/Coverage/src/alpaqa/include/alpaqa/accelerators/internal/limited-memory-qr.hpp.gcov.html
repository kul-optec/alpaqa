<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - 5b9b2a9b0cf65378ad6203cc4a68a62f8222e9e6 - src/alpaqa/include/alpaqa/accelerators/internal/limited-memory-qr.hpp</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../index.html">top level</a> - <a href="index.html">src/alpaqa/include/alpaqa/accelerators/internal</a> - limited-memory-qr.hpp</td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">5b9b2a9b0cf65378ad6203cc4a68a62f8222e9e6</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">116</td>
            <td class="headerCovTableEntry">117</td>
            <td class="headerCovTableEntryHi">99.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2023-09-06 12:43:25</td>
            <td></td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #pragma once</a>
<a name="2"><span class="lineNum">       2 </span>            : </a>
<a name="3"><span class="lineNum">       3 </span>            : #include &lt;alpaqa/config/config.hpp&gt;</a>
<a name="4"><span class="lineNum">       4 </span>            : #include &lt;alpaqa/util/ringbuffer.hpp&gt;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &lt;Eigen/Jacobi&gt;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;type_traits&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : </a>
<a name="8"><span class="lineNum">       8 </span>            : namespace alpaqa {</a>
<a name="9"><span class="lineNum">       9 </span>            : </a>
<a name="10"><span class="lineNum">      10 </span>            : /// Incremental QR factorization using modified Gram-Schmidt with</a>
<a name="11"><span class="lineNum">      11 </span>            : /// reorthogonalization.</a>
<a name="12"><span class="lineNum">      12 </span>            : ///</a>
<a name="13"><span class="lineNum">      13 </span>            : /// Computes A = QR while allowing efficient removal of the first</a>
<a name="14"><span class="lineNum">      14 </span>            : /// column of A or adding new columns at the end of A.</a>
<a name="15"><span class="lineNum">      15 </span>            : template &lt;Config Conf = DefaultConfig&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : class LimitedMemoryQR {</a>
<a name="17"><span class="lineNum">      17 </span>            :   public:</a>
<a name="18"><span class="lineNum">      18 </span>            :     USING_ALPAQA_CONFIG(Conf);</a>
<a name="19"><span class="lineNum">      19 </span><span class="lineCov">          2 :     LimitedMemoryQR() = default;</span></a>
<a name="20"><span class="lineNum">      20 </span>            : </a>
<a name="21"><span class="lineNum">      21 </span>            :     /// @param  n</a>
<a name="22"><span class="lineNum">      22 </span>            :     ///         The size of the vectors, the number of rows of A.</a>
<a name="23"><span class="lineNum">      23 </span>            :     /// @param  m</a>
<a name="24"><span class="lineNum">      24 </span>            :     ///         The maximum number of columns of A.</a>
<a name="25"><span class="lineNum">      25 </span>            :     ///</a>
<a name="26"><span class="lineNum">      26 </span>            :     /// The maximum dimensions of Q are n×m and the maximum dimensions of R are</a>
<a name="27"><span class="lineNum">      27 </span>            :     /// m×m.</a>
<a name="28"><span class="lineNum">      28 </span><span class="lineCov">          7 :     LimitedMemoryQR(length_t n, length_t m) : Q(n, m), R(m, m) {}</span></a>
<a name="29"><span class="lineNum">      29 </span>            : </a>
<a name="30"><span class="lineNum">      30 </span><span class="lineCov">         82 :     length_t n() const { return Q.rows(); }</span></a>
<a name="31"><span class="lineNum">      31 </span><span class="lineCov">       4179 :     length_t m() const { return Q.cols(); }</span></a>
<a name="32"><span class="lineNum">      32 </span>            :     length_t size() const { return n(); }</a>
<a name="33"><span class="lineNum">      33 </span>            :     length_t history() const { return m(); }</a>
<a name="34"><span class="lineNum">      34 </span>            : </a>
<a name="35"><span class="lineNum">      35 </span>            :     /// Add the given column to the right.</a>
<a name="36"><span class="lineNum">      36 </span>            :     template &lt;class VecV&gt;</a>
<a name="37"><span class="lineNum">      37 </span><span class="lineCov">        197 :     void add_column(const VecV &amp;v) {</span></a>
<a name="38"><span class="lineNum">      38 </span><span class="lineCov">        197 :         assert(num_columns() &lt; m());</span></a>
<a name="39"><span class="lineNum">      39 </span>            : </a>
<a name="40"><span class="lineNum">      40 </span><span class="lineCov">        197 :         auto q = Q.col(q_idx);</span></a>
<a name="41"><span class="lineNum">      41 </span><span class="lineCov">        197 :         auto r = R.col(r_idx_end);</span></a>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<a name="43"><span class="lineNum">      43 </span>            :         // Modified Gram-Schmidt to make q orthogonal to Q</a>
<a name="44"><span class="lineNum">      44 </span><span class="lineCov">        197 :         q = v;</span></a>
<a name="45"><span class="lineNum">      45 </span><span class="lineCov">       1138 :         for (index_t i = 0; i &lt; q_idx; ++i) {</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineCov">        941 :             real_t s = Q.col(i).dot(q);</span></a>
<a name="47"><span class="lineNum">      47 </span><span class="lineCov">        941 :             r(i)     = s;</span></a>
<a name="48"><span class="lineNum">      48 </span><span class="lineCov">        941 :             q -= s * Q.col(i);</span></a>
<a name="49"><span class="lineNum">      49 </span>            :         }</a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span>            :         // Compute the norms of orthogonalized q and original v</a>
<a name="52"><span class="lineNum">      52 </span><span class="lineCov">        197 :         real_t norm_q = q.norm();</span></a>
<a name="53"><span class="lineNum">      53 </span><span class="lineCov">        197 :         real_t norm_v = v.norm();</span></a>
<a name="54"><span class="lineNum">      54 </span>            : </a>
<a name="55"><span class="lineNum">      55 </span>            :         // If ‖q‖ is significantly smaller than ‖v‖, perform</a>
<a name="56"><span class="lineNum">      56 </span>            :         // reorthogonalization</a>
<a name="57"><span class="lineNum">      57 </span><span class="lineCov">        197 :         auto η = real_t(0.7);</span></a>
<a name="58"><span class="lineNum">      58 </span><span class="lineCov">        348 :         while (norm_q &lt; η * norm_v) {</span></a>
<a name="59"><span class="lineNum">      59 </span><span class="lineCov">        151 :             ++reorth_count;</span></a>
<a name="60"><span class="lineNum">      60 </span><span class="lineCov">       1003 :             for (index_t i = 0; i &lt; q_idx; ++i) {</span></a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">        852 :                 real_t s = Q.col(i).dot(q);</span></a>
<a name="62"><span class="lineNum">      62 </span><span class="lineCov">        852 :                 r(i) += s;</span></a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">        852 :                 q -= s * Q.col(i);</span></a>
<a name="64"><span class="lineNum">      64 </span>            :             }</a>
<a name="65"><span class="lineNum">      65 </span><span class="lineCov">        151 :             norm_v = norm_q;</span></a>
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">        151 :             norm_q = q.norm();</span></a>
<a name="67"><span class="lineNum">      67 </span>            :         }</a>
<a name="68"><span class="lineNum">      68 </span>            : </a>
<a name="69"><span class="lineNum">      69 </span>            :         // Normalize q such that new matrix (Q q) remains orthogonal (i.e. has</a>
<a name="70"><span class="lineNum">      70 </span>            :         // orthonormal columns)</a>
<a name="71"><span class="lineNum">      71 </span><span class="lineCov">        197 :         r(q_idx) = norm_q;</span></a>
<a name="72"><span class="lineNum">      72 </span><span class="lineCov">        197 :         q /= norm_q;</span></a>
<a name="73"><span class="lineNum">      73 </span>            :         // Keep track of the minimum/maximum diagonal element of R</a>
<a name="74"><span class="lineNum">      74 </span><span class="lineCov">        197 :         min_eig = std::min(min_eig, norm_q);</span></a>
<a name="75"><span class="lineNum">      75 </span><span class="lineCov">        197 :         max_eig = std::max(max_eig, norm_q);</span></a>
<a name="76"><span class="lineNum">      76 </span>            : </a>
<a name="77"><span class="lineNum">      77 </span>            :         // Increment indices, add a column to Q and R.</a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">        197 :         ++q_idx;</span></a>
<a name="79"><span class="lineNum">      79 </span><span class="lineCov">        197 :         r_idx_end = r_succ(r_idx_end);</span></a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">        197 :     }</span></a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span>            :     /// Remove the leftmost column.</a>
<a name="83"><span class="lineNum">      83 </span><span class="lineCov">         66 :     void remove_column() {</span></a>
<a name="84"><span class="lineNum">      84 </span><span class="lineCov">         66 :         assert(num_columns() &gt; 0);</span></a>
<a name="85"><span class="lineNum">      85 </span>            : </a>
<a name="86"><span class="lineNum">      86 </span>            :         // After removing the first column of the upper triangular matrix R,</a>
<a name="87"><span class="lineNum">      87 </span>            :         // it becomes upper Hessenberg. Givens rotations are used to make it</a>
<a name="88"><span class="lineNum">      88 </span>            :         // triangular again.</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineCov">         66 :         Eigen::JacobiRotation&lt;real_t&gt; G;</span></a>
<a name="90"><span class="lineNum">      90 </span><span class="lineCov">         66 :         index_t r = 0;                   // row index of R</span></a>
<a name="91"><span class="lineNum">      91 </span><span class="lineCov">         66 :         index_t c = r_succ(r_idx_start); // column index of R in storage</span></a>
<a name="92"><span class="lineNum">      92 </span>            :         // Loop over the diagonal elements of R:</a>
<a name="93"><span class="lineNum">      93 </span><span class="lineCov">        522 :         while (r &lt; q_idx - 1) {</span></a>
<a name="94"><span class="lineNum">      94 </span>            :             // Compute the Givens rotation that makes the subdiagonal element</a>
<a name="95"><span class="lineNum">      95 </span>            :             // of column c of R zero.</a>
<a name="96"><span class="lineNum">      96 </span><span class="lineCov">        456 :             G.makeGivens(R(r, c), R(r + 1, c), &amp;R(r, c));</span></a>
<a name="97"><span class="lineNum">      97 </span>            :             // Apply it to the remaining columns of R.</a>
<a name="98"><span class="lineNum">      98 </span>            :             // Not the current column, because the diagonal element was updated</a>
<a name="99"><span class="lineNum">      99 </span>            :             // by the makeGivens function, and the subdiagonal element doesn't</a>
<a name="100"><span class="lineNum">     100 </span>            :             // have to be set to zero explicitly, it's implicit.</a>
<a name="101"><span class="lineNum">     101 </span>            :             // Also not the previous columns, because they are already</a>
<a name="102"><span class="lineNum">     102 </span>            :             // implicitly zero below the diagonal and this rotation wouldn't</a>
<a name="103"><span class="lineNum">     103 </span>            :             // have any effect there.</a>
<a name="104"><span class="lineNum">     104 </span>            :             // TODO: can this be sped up by applying it in two blocks instead</a>
<a name="105"><span class="lineNum">     105 </span>            :             //       of column by column?</a>
<a name="106"><span class="lineNum">     106 </span><span class="lineCov">       2162 :             for (index_t cc = r_succ(c); cc != r_idx_end; cc = r_succ(cc))</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">       1706 :                 R.col(cc).applyOnTheLeft(r, r + 1, G.adjoint());</span></a>
<a name="108"><span class="lineNum">     108 </span>            :             // Apply the inverse of the Givens rotation to Q.</a>
<a name="109"><span class="lineNum">     109 </span><span class="lineCov">        456 :             Q.block(0, 0, Q.rows(), q_idx).applyOnTheRight(r, r + 1, G);</span></a>
<a name="110"><span class="lineNum">     110 </span>            :             // Keep track of the minimum/maximum diagonal element of R</a>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">        456 :             min_eig = std::min(min_eig, R(r, c));</span></a>
<a name="112"><span class="lineNum">     112 </span><span class="lineCov">        456 :             max_eig = std::max(max_eig, R(r, c));</span></a>
<a name="113"><span class="lineNum">     113 </span>            :             // Advance indices to next diagonal element of R.</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">        456 :             ++r;</span></a>
<a name="115"><span class="lineNum">     115 </span><span class="lineCov">        456 :             c = r_succ(c);</span></a>
<a name="116"><span class="lineNum">     116 </span>            :         }</a>
<a name="117"><span class="lineNum">     117 </span>            :         // Remove rightmost column of Q, since it corresponds to the bottom row</a>
<a name="118"><span class="lineNum">     118 </span>            :         // of R, which was set to zero by the Givens rotations</a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">         66 :         --q_idx;</span></a>
<a name="120"><span class="lineNum">     120 </span>            :         // Remove the first column of R.</a>
<a name="121"><span class="lineNum">     121 </span><span class="lineCov">         66 :         r_idx_start = r_succ(r_idx_start);</span></a>
<a name="122"><span class="lineNum">     122 </span><span class="lineCov">         66 :     }</span></a>
<a name="123"><span class="lineNum">     123 </span>            : </a>
<a name="124"><span class="lineNum">     124 </span>            :     /// Solve the least squares problem Ax = b.</a>
<a name="125"><span class="lineNum">     125 </span>            :     /// Do not divide by elements that are smaller in absolute value than @p tol.</a>
<a name="126"><span class="lineNum">     126 </span>            :     template &lt;class VecB, class VecX&gt;</a>
<a name="127"><span class="lineNum">     127 </span><span class="lineCov">        174 :     void solve_col(const VecB &amp;b, VecX &amp;x, real_t tol = 0) const {</span></a>
<a name="128"><span class="lineNum">     128 </span>            :         // Iterate over the diagonal of R, starting at the bottom right,</a>
<a name="129"><span class="lineNum">     129 </span>            :         // this is standard back substitution</a>
<a name="130"><span class="lineNum">     130 </span>            :         // (recall that R is stored in a circular buffer, so R.col(i) is</a>
<a name="131"><span class="lineNum">     131 </span>            :         // not the mathematical i-th column)</a>
<a name="132"><span class="lineNum">     132 </span><span class="lineCov">        174 :         auto rev_bgn = ring_reverse_iter().begin();</span></a>
<a name="133"><span class="lineNum">     133 </span><span class="lineCov">        174 :         auto rev_end = ring_reverse_iter().end();</span></a>
<a name="134"><span class="lineNum">     134 </span><span class="lineCov">        174 :         auto fwd_end = ring_iter().end();</span></a>
<a name="135"><span class="lineNum">     135 </span><span class="lineCov">       1261 :         for (auto it_d = rev_bgn; it_d != rev_end; ++it_d) {</span></a>
<a name="136"><span class="lineNum">     136 </span>            :             // Row/column index of diagonal element of R</a>
<a name="137"><span class="lineNum">     137 </span><span class="lineCov">       1087 :             auto [rR, cR] = *it_d;</span></a>
<a name="138"><span class="lineNum">     138 </span>            :             // Don't divide by very small diagonal elements</a>
<a name="139"><span class="lineNum">     139 </span><span class="lineCov">       1087 :             if (std::abs(R(rR, cR)) &lt; tol) {</span></a>
<a name="140"><span class="lineNum">     140 </span><span class="lineCov">          8 :                 x(rR) = real_t{0};</span></a>
<a name="141"><span class="lineNum">     141 </span><span class="lineCov">          8 :                 continue;</span></a>
<a name="142"><span class="lineNum">     142 </span>            :             }</a>
<a name="143"><span class="lineNum">     143 </span>            :             // (r is the zero-based mathematical index, c is the index in</a>
<a name="144"><span class="lineNum">     144 </span>            :             // the circular buffer)</a>
<a name="145"><span class="lineNum">     145 </span><span class="lineCov">       1079 :             x(rR) = Q.col(rR).transpose() * b; // Compute rhs Qᵀb</span></a>
<a name="146"><span class="lineNum">     146 </span>            :             // In the current row of R, iterate over the elements to the</a>
<a name="147"><span class="lineNum">     147 </span>            :             // right of the diagonal</a>
<a name="148"><span class="lineNum">     148 </span>            :             // Iterating from left to right seems to give better results</a>
<a name="149"><span class="lineNum">     149 </span><span class="lineCov">       4874 :             for (auto it_c = it_d.forwardit; it_c != fwd_end; ++it_c) {</span></a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">       3795 :                 auto [rX2, cR2] = *it_c;</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">       3795 :                 x(rR) -= R(rR, cR2) * x(rX2);</span></a>
<a name="152"><span class="lineNum">     152 </span>            :             }</a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">       1079 :             x(rR) /= R(rR, cR); // Divide by diagonal element</span></a>
<a name="154"><span class="lineNum">     154 </span>            :         }</a>
<a name="155"><span class="lineNum">     155 </span><span class="lineCov">        174 :     }</span></a>
<a name="156"><span class="lineNum">     156 </span>            : </a>
<a name="157"><span class="lineNum">     157 </span>            :     /// Solve the least squares problem AX = B.</a>
<a name="158"><span class="lineNum">     158 </span>            :     /// Do not divide by elements that are smaller in absolute value than @p tol.</a>
<a name="159"><span class="lineNum">     159 </span>            :     template &lt;class MatB, class MatX&gt;</a>
<a name="160"><span class="lineNum">     160 </span><span class="lineCov">          2 :     void solve(const MatB &amp;B, MatX &amp;X, real_t tol = 0) const {</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineCov">          2 :         assert(B.cols() &lt;= X.cols());</span></a>
<a name="162"><span class="lineNum">     162 </span><span class="lineCov">          2 :         assert(B.rows() &gt;= Q.rows());</span></a>
<a name="163"><span class="lineNum">     163 </span><span class="lineCov">          2 :         assert(X.rows() &gt;= Eigen::Index(num_columns()));</span></a>
<a name="164"><span class="lineNum">     164 </span>            :         // Each column of the right hand side is solved as an individual system</a>
<a name="165"><span class="lineNum">     165 </span><span class="lineCov">          6 :         for (Eigen::Index cB = 0; cB &lt; B.cols(); ++cB) {</span></a>
<a name="166"><span class="lineNum">     166 </span><span class="lineCov">          4 :             auto b = B.col(cB);</span></a>
<a name="167"><span class="lineNum">     167 </span><span class="lineCov">          4 :             auto x = X.col(cB);</span></a>
<a name="168"><span class="lineNum">     168 </span><span class="lineCov">          4 :             solve_col(b, x, tol);</span></a>
<a name="169"><span class="lineNum">     169 </span>            :         }</a>
<a name="170"><span class="lineNum">     170 </span><span class="lineCov">          2 :     }</span></a>
<a name="171"><span class="lineNum">     171 </span>            : </a>
<a name="172"><span class="lineNum">     172 </span>            :     template &lt;class Derived&gt;</a>
<a name="173"><span class="lineNum">     173 </span>            :     using solve_ret_t = std::conditional_t&lt;</a>
<a name="174"><span class="lineNum">     174 </span>            :         Eigen::internal::traits&lt;Derived&gt;::ColsAtCompileTime == 1, vec, mat&gt;;</a>
<a name="175"><span class="lineNum">     175 </span>            : </a>
<a name="176"><span class="lineNum">     176 </span>            :     /// Solve the least squares problem AX = B.</a>
<a name="177"><span class="lineNum">     177 </span>            :     template &lt;class Derived&gt;</a>
<a name="178"><span class="lineNum">     178 </span><span class="lineCov">          1 :     solve_ret_t&lt;Derived&gt; solve(const Eigen::DenseBase&lt;Derived&gt; &amp;B) {</span></a>
<a name="179"><span class="lineNum">     179 </span><span class="lineCov">          1 :         solve_ret_t&lt;Derived&gt; X(m(), B.cols());</span></a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">          1 :         solve(B, X);</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">          1 :         return X;</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="183"><span class="lineNum">     183 </span>            : </a>
<a name="184"><span class="lineNum">     184 </span>            :     /// Get the full, raw storage for the orthogonal matrix Q.</a>
<a name="185"><span class="lineNum">     185 </span>            :     const mat &amp;get_raw_Q() const { return Q; }</a>
<a name="186"><span class="lineNum">     186 </span>            :     /// Get the full, raw storage for the upper triangular matrix R.</a>
<a name="187"><span class="lineNum">     187 </span>            :     /// The columns of this matrix are permuted because it's stored as a</a>
<a name="188"><span class="lineNum">     188 </span>            :     /// circular buffer for efficiently appending columns to the end and</a>
<a name="189"><span class="lineNum">     189 </span>            :     /// popping columns from the front.</a>
<a name="190"><span class="lineNum">     190 </span>            :     const mat &amp;get_raw_R() const { return R; }</a>
<a name="191"><span class="lineNum">     191 </span>            : </a>
<a name="192"><span class="lineNum">     192 </span>            :     /// Get the full storage for the upper triangular matrix R but with the</a>
<a name="193"><span class="lineNum">     193 </span>            :     /// columns in the correct order.</a>
<a name="194"><span class="lineNum">     194 </span>            :     /// @note   Meant for tests only, creates a permuted copy.</a>
<a name="195"><span class="lineNum">     195 </span><span class="lineCov">         43 :     mat get_full_R() const {</span></a>
<a name="196"><span class="lineNum">     196 </span><span class="lineCov">         43 :         if (r_idx_start == 0)</span></a>
<a name="197"><span class="lineNum">     197 </span><span class="lineCov">         20 :             return R;</span></a>
<a name="198"><span class="lineNum">     198 </span>            :         // Using a permutation matrix here isn't as efficient as rotating the</a>
<a name="199"><span class="lineNum">     199 </span>            :         // matrix manually, but this function is only used in tests, so it</a>
<a name="200"><span class="lineNum">     200 </span>            :         // shouldn't matter.</a>
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">         23 :         Eigen::PermutationMatrix&lt;Eigen::Dynamic&gt; P(R.cols());</span></a>
<a name="202"><span class="lineNum">     202 </span><span class="lineCov">         23 :         P.setIdentity();</span></a>
<a name="203"><span class="lineNum">     203 </span><span class="lineCov">         23 :         std::rotate(P.indices().data(), P.indices().data() + r_idx_start,</span></a>
<a name="204"><span class="lineNum">     204 </span><span class="lineCov">         23 :                     P.indices().data() + P.size());</span></a>
<a name="205"><span class="lineNum">     205 </span><span class="lineCov">         23 :         return R * P;</span></a>
<a name="206"><span class="lineNum">     206 </span><span class="lineCov">         23 :     }</span></a>
<a name="207"><span class="lineNum">     207 </span>            :     /// Get the matrix R such that Q times R is the original matrix.</a>
<a name="208"><span class="lineNum">     208 </span>            :     /// @note   Meant for tests only, creates a permuted copy.</a>
<a name="209"><span class="lineNum">     209 </span><span class="lineCov">         43 :     mat get_R() const {</span></a>
<a name="210"><span class="lineNum">     210 </span>            :         return get_full_R()</a>
<a name="211"><span class="lineNum">     211 </span><span class="lineCov">         86 :             .block(0, 0, q_idx, q_idx)</span></a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">        129 :             .template triangularView&lt;Eigen::Upper&gt;();</span></a>
<a name="213"><span class="lineNum">     213 </span>            :     }</a>
<a name="214"><span class="lineNum">     214 </span>            :     /// Get the matrix Q such that Q times R is the original matrix.</a>
<a name="215"><span class="lineNum">     215 </span>            :     /// @note   Meant for tests only, creates a copy.</a>
<a name="216"><span class="lineNum">     216 </span><span class="lineCov">         94 :     mat get_Q() const { return Q.block(0, 0, n(), q_idx); }</span></a>
<a name="217"><span class="lineNum">     217 </span>            : </a>
<a name="218"><span class="lineNum">     218 </span>            :     /// Multiply the matrix R by a scalar.</a>
<a name="219"><span class="lineNum">     219 </span><span class="lineCov">          1 :     void scale_R(real_t scal) {</span></a>
<a name="220"><span class="lineNum">     220 </span><span class="lineCov">          5 :         for (auto [i, r_idx] : ring_iter())</span></a>
<a name="221"><span class="lineNum">     221 </span><span class="lineCov">          3 :             R.col(r_idx).topRows(i + 1) *= scal;</span></a>
<a name="222"><span class="lineNum">     222 </span><span class="lineCov">          1 :         min_eig *= scal;</span></a>
<a name="223"><span class="lineNum">     223 </span><span class="lineCov">          1 :         max_eig *= scal;</span></a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">          1 :     }</span></a>
<a name="225"><span class="lineNum">     225 </span>            : </a>
<a name="226"><span class="lineNum">     226 </span>            :     /// Get the number of MGS reorthogonalizations.</a>
<a name="227"><span class="lineNum">     227 </span>            :     unsigned long get_reorth_count() const { return reorth_count; }</a>
<a name="228"><span class="lineNum">     228 </span>            :     /// Reset the number of MGS reorthogonalizations.</a>
<a name="229"><span class="lineNum">     229 </span>            :     void clear_reorth_count() { reorth_count = 0; }</a>
<a name="230"><span class="lineNum">     230 </span>            : </a>
<a name="231"><span class="lineNum">     231 </span>            :     /// Get the minimum eigenvalue of R.</a>
<a name="232"><span class="lineNum">     232 </span>            :     real_t get_min_eig() const { return min_eig; }</a>
<a name="233"><span class="lineNum">     233 </span>            :     /// Get the maximum eigenvalue of R.</a>
<a name="234"><span class="lineNum">     234 </span><span class="lineCov">        170 :     real_t get_max_eig() const { return max_eig; }</span></a>
<a name="235"><span class="lineNum">     235 </span>            : </a>
<a name="236"><span class="lineNum">     236 </span>            :     /// Reset all indices, clearing the Q and R matrices.</a>
<a name="237"><span class="lineNum">     237 </span><span class="lineCov">         25 :     void reset() {</span></a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">         25 :         q_idx        = 0;</span></a>
<a name="239"><span class="lineNum">     239 </span><span class="lineCov">         25 :         r_idx_start  = 0;</span></a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">         25 :         r_idx_end    = 0;</span></a>
<a name="241"><span class="lineNum">     241 </span><span class="lineCov">         25 :         reorth_count = 0;</span></a>
<a name="242"><span class="lineNum">     242 </span><span class="lineCov">         25 :         min_eig      = +inf&lt;config_t&gt;;</span></a>
<a name="243"><span class="lineNum">     243 </span><span class="lineCov">         25 :         max_eig      = -inf&lt;config_t&gt;;</span></a>
<a name="244"><span class="lineNum">     244 </span><span class="lineCov">         25 :     }</span></a>
<a name="245"><span class="lineNum">     245 </span>            : </a>
<a name="246"><span class="lineNum">     246 </span>            :     /// Re-allocate storage for a problem with a different size. Causes</a>
<a name="247"><span class="lineNum">     247 </span>            :     /// a @ref reset.</a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">         12 :     void resize(length_t n, length_t m) {</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">         12 :         Q.resize(n, m);</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">         12 :         R.resize(m, m);</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">         12 :         reset();</span></a>
<a name="252"><span class="lineNum">     252 </span><span class="lineCov">         12 :     }</span></a>
<a name="253"><span class="lineNum">     253 </span>            : </a>
<a name="254"><span class="lineNum">     254 </span>            :     /// Get the number of columns that are currently stored.</a>
<a name="255"><span class="lineNum">     255 </span><span class="lineCov">        605 :     length_t num_columns() const { return q_idx; }</span></a>
<a name="256"><span class="lineNum">     256 </span>            :     /// Get the head index of the circular buffer (points to the oldest</a>
<a name="257"><span class="lineNum">     257 </span>            :     /// element).</a>
<a name="258"><span class="lineNum">     258 </span>            :     index_t ring_head() const { return r_idx_start; }</a>
<a name="259"><span class="lineNum">     259 </span>            :     /// Get the tail index of the circular buffer (points to one past the most</a>
<a name="260"><span class="lineNum">     260 </span>            :     /// recent element).</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">        171 :     index_t ring_tail() const { return r_idx_end; }</span></a>
<a name="262"><span class="lineNum">     262 </span>            :     /// Get the next index in the circular buffer.</a>
<a name="263"><span class="lineNum">     263 </span>            :     index_t ring_next(index_t i) const { return r_succ(i); }</a>
<a name="264"><span class="lineNum">     264 </span>            :     /// Get the previous index in the circular buffer.</a>
<a name="265"><span class="lineNum">     265 </span>            :     index_t ring_prev(index_t i) const { return r_pred(i); }</a>
<a name="266"><span class="lineNum">     266 </span>            :     /// Get the number of columns currently stored in the buffer.</a>
<a name="267"><span class="lineNum">     267 </span>            :     length_t current_history() const { return q_idx; }</a>
<a name="268"><span class="lineNum">     268 </span>            : </a>
<a name="269"><span class="lineNum">     269 </span>            :     /// Get iterators in the circular buffer.</a>
<a name="270"><span class="lineNum">     270 </span><span class="lineCov">        863 :     CircularRange&lt;index_t&gt; ring_iter() const {</span></a>
<a name="271"><span class="lineNum">     271 </span><span class="lineCov">        863 :         return {q_idx, r_idx_start, r_idx_end, m()};</span></a>
<a name="272"><span class="lineNum">     272 </span>            :     }</a>
<a name="273"><span class="lineNum">     273 </span>            :     /// Get reverse iterators in the circular buffer.</a>
<a name="274"><span class="lineNum">     274 </span><span class="lineCov">        348 :     ReverseCircularRange&lt;index_t&gt; ring_reverse_iter() const {</span></a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">        348 :         return ring_iter();</span></a>
<a name="276"><span class="lineNum">     276 </span>            :     }</a>
<a name="277"><span class="lineNum">     277 </span>            : </a>
<a name="278"><span class="lineNum">     278 </span>            :   private:</a>
<a name="279"><span class="lineNum">     279 </span>            :     mat Q; ///&lt; Storage for orthogonal factor Q.</a>
<a name="280"><span class="lineNum">     280 </span>            :     mat R; ///&lt; Storage for upper triangular factor R.</a>
<a name="281"><span class="lineNum">     281 </span>            : </a>
<a name="282"><span class="lineNum">     282 </span>            :     index_t q_idx       = 0; ///&lt; Number of columns of Q being stored.</a>
<a name="283"><span class="lineNum">     283 </span>            :     index_t r_idx_start = 0; ///&lt; Index of the first column of R.</a>
<a name="284"><span class="lineNum">     284 </span>            :     index_t r_idx_end   = 0; ///&lt; Index of the one-past-last column of R.</a>
<a name="285"><span class="lineNum">     285 </span>            : </a>
<a name="286"><span class="lineNum">     286 </span>            :     unsigned long reorth_count = 0; ///&lt; Number of MGS reorthogonalizations.</a>
<a name="287"><span class="lineNum">     287 </span>            : </a>
<a name="288"><span class="lineNum">     288 </span>            :     real_t min_eig = +inf&lt;config_t&gt;; ///&lt; Minimum eigenvalue of R.</a>
<a name="289"><span class="lineNum">     289 </span>            :     real_t max_eig = -inf&lt;config_t&gt;; ///&lt; Maximum eigenvalue of R.</a>
<a name="290"><span class="lineNum">     290 </span>            : </a>
<a name="291"><span class="lineNum">     291 </span>            :     /// Get the next index in the circular storage for R.</a>
<a name="292"><span class="lineNum">     292 </span><span class="lineCov">       2947 :     index_t r_succ(index_t i) const { return i + 1 &lt; m() ? i + 1 : 0; }</span></a>
<a name="293"><span class="lineNum">     293 </span>            :     /// Get the previous index in the circular storage for R.</a>
<a name="294"><span class="lineNum">     294 </span>            :     index_t r_pred(index_t i) const { return i == 0 ? m() - 1 : i - 1; }</a>
<a name="295"><span class="lineNum">     295 </span>            : };</a>
<a name="296"><span class="lineNum">     296 </span>            : </a>
<a name="297"><span class="lineNum">     297 </span>            : } // namespace alpaqa</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.15</a></td></tr>
  </table>
  <br>

</body>
</html>
