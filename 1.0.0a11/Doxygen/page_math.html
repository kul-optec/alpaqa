<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>alpaqa: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  },
  loader: {
    load: ['[tex]/ams']
  },
  tex: {
    macros: {    Reals: "{\\mathrm{I\\!R}}",
    Nats: "{\\mathrm{I\\!N}}",
    Cplx: "{\\mathbb{C}}",
    R: "{\\Reals}",
    N: "{\\Nats}",
    C: "{\\Cplx}",
    Rn: "{\\Reals^n}",
    Rm: "{\\Reals^m}",
    gph: "{\\operatorname{\\mathbf{gph}}}",
    zer: "{\\operatorname{\\mathbf{zer}}}",
    fix: "{\\operatorname{\\mathbf{fix}}}",
    minimize: "{\\operatorname*{\\mathbf{minimize}}}",
    st: "{\\operatorname*{\\mathbf{s.\\!t.}}}",
    argmin: "{\\operatorname*{\\mathbf{arg\\,min}}}",
    argmax: "{\\operatorname*{\\mathbf{arg\\,max}}}",
    subjto: "{\\operatorname*{\\mathbf{subject\\;to}}}",
    prox: "{\\operatorname{\\mathbf{prox}}}",
    Hilb: "{\\mathcal{H}}",
    proj: ["{\\operatorname{\\mathbf{\\Pi}_\\mathnormal{#1}}}",1],
    dist: "{\\operatorname{\\mathbf{dist}}}",
    Id: "{\\mathrm{Id}}",
    I: "{\\mathrm{I}}",
    one: "{\\mathbf{1}}",
    defeq: "{\\triangleq}",
    inprod: ["{\\left\\langle {#1} \\,\\middle|\\, {#2} \\right\\rangle}",2],
    norm: ["{\\left\\| {#1} \\vphantom{X} \\right\\|}",1],
    normsq: ["{\\norm{#1}^2}",1],
    defset: ["{\\left\\{ {#1} \\;\\middle|\\; {#2} \\right\\}}",2],
    tp: ["{#1^\\top}",1],
    ttp: ["{#1^{\\!\\top\\!}}",1],
    herm: ["{#1^\\mathrm{H}}",1],
    invherm: ["{#1^{-\\mathrm{H}}}",1],
    inv: ["{#1^{-1}}",1],
    pinv: ["{#1^\\dagger}",1],
    lconj: "{\\overline}",
    sconj: ["{#1^*}",1],
    iddots: "{\\mathinner{\\kern1mu\\raise1pt{.}\\kern2mu\\raise4pt{.}\\kern2mu\\raise7pt{\\Rule{0pt}{7pt}{0pt}.}\\kern1mu}}",
    imagfun: ["{\\left(#1\\right)\\left(#2\\right)}",2],
    Lagr: "{\\mathcal{L}}",
    jac: "{\\mathrm{J}}",
    dft: "{\\operatorname{\\mathbf{dft}}}",
    cbrt: ["{\\sqrt[3]{#1}}",1],
    sgn: "{\\operatorname{\\mathbf{sgn}}}",
    setmap: "{\\rightrightarrows}",
    lammin: "{\\lambda_\\text{min}}",
    lammax: "{\\lambda_\\text{max}}",
    Sc: "{\\mathcal{S}}",
    Scstar: "{\\mathcal{S}^*}",
    diag: "{\\operatorname{\\mathbf{diag}}}",
    blkdiag: "{\\operatorname{\\mathbf{blkdiag}}}",
    posdef: "{\\succ}",
    possdef: "{\\succeq}",
    half: "{\\tfrac{1}{2}}",
    hhbar: "{\\hbar}",
    barxuk: "{\\bar x^k\\!, \\bar u^k}",
    },
    packages: ['base','configmacros','newcommand','ams']
  }
};
window.MathJax.tex.tags = 'ams';
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&family=Roboto:wght@400&family=Roboto:wght@500&display=swap" rel="stylesheet">
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
  <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">alpaqa<span id="projectnumber">&#160;<code><a href="/alpaqa/index.html">1.0.0a11</a></code></span>
   </div>
   <div id="projectbrief">Nonconvex constrained optimization</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Math </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md22">Augmented Lagrangian method</a><ul><li class="level2"><a href="#autotoc_md23">Definitions</a></li>
<li class="level2"><a href="#autotoc_md24">The augmented Lagrangian method algorithm</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md25">PANOC</a><ul><li class="level2"><a href="#autotoc_md26">Evaluation</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md27">Structured PANOC</a></li>
<li class="level1"><a href="#autotoc_md28">PANOC-OCP</a><ul><li class="level2"><a href="#autotoc_md29">Problem formulation</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md_doxygen_pages_Math"></a></p>
<h1><a class="anchor" id="autotoc_md22"></a>
Augmented Lagrangian method</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Definitions</h2>
<p>The nonlinear program we wish to solve is of the form:  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        &amp; \underset{x}{\text{minimize}}
        &amp; &amp; f(x) &amp;&amp;&amp;&amp; f : \Rn \rightarrow \R \\
        &amp; \text{subject to}
        &amp; &amp; \underline{x} \le x \le \overline{x} \\
        &amp;&amp;&amp; \underline{z} \le g(x) \le \overline{z} &amp;&amp;&amp;&amp; g : \Rn \rightarrow \R^m
    \end{aligned}
    \label{eq:problem-orig}
    \tag{P}
\end{equation}
\]
</p>
<p>Define the convex sets \(C\) and \(D\) as  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        C &amp;= \left\{ x \in \Rn \mid \underline x \le x \le \overline x \right\} \\
        D &amp;= \left\{ z \in \R^m \mid \underline z \le z \le \overline z \right\}. \\
    \end{aligned}
    \label{eq:setCD}
\end{equation}
\]
</p>
<p> These rectangular boxes can be decomposed as Cartesian products of 1-dimensional closed intervals:  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        C &amp;= C_1 \times C_2 \times \dots \times C_n \quad&amp;&amp;\text{where } C_i = \left[ \underline x_i, \overline x_i \right] \\
        D &amp;= D_1 \times D_2 \times \dots \times D_m \quad&amp;&amp;\text{where } D_i = \left[ \underline z_i, \overline z_i \right] \\
    \end{aligned}
    \label{eq:setCDcartprod}
\end{equation}
\]
</p>
<p> Using these definitions, problem \(\eqref{eq:problem-orig}\) can equivalently be expressed as  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        &amp; \underset{x\in C}{\text{minimize}}
        &amp; &amp; f(x) \\
        &amp; \text{subject to}
        &amp; &amp; g(x) \in D.
    \end{aligned}
    \label{eq:problem-in-setCD}
\end{equation}
\]
</p>
<p>After introduction of a slack variable \(z\), problem \(\eqref{eq:problem-in-setCD}\) can be stated as</p>
<p class="formulaDsp">
\[
\begin{equation}
    \label{eq:problem-origCD-alm}
    \tag{P-ALM}
    \begin{aligned}
        &amp; \underset{x\in C,\; z\in D}{\text{minimize}}
        &amp; &amp; f(x) \\
        &amp; \text{subject to}
        &amp; &amp; g(x) - z = 0.
    \end{aligned}
\end{equation}
\]
</p>
<p>The Lagrangian function of problem \(\eqref{eq:problem-origCD-alm}\) is given by:  </p><p class="formulaDsp">
\[
\begin{equation}\label{eq:def-lagr}
    \begin{aligned}
        \Lagr : \Rn \times \R^m \times \R^m \rightarrow \R : (x, z, y) &amp;\mapsto \Lagr(x, z, y) \\
        &amp;\,\triangleq\, f(x) + \left\langle g(x) - z,\; y\right\rangle.
    \end{aligned}
\end{equation}
\]
</p>
<p> The vector \(y \in \R^m\) is called the vector of Lagrange multipliers.</p>
<p>The augmented Lagrangian function with penalty factor \(\Sigma\) of the problem \(\eqref{eq:problem-origCD-alm}\) is defined as the sum of the Lagrangian function and a quadratic term that penalizes the constraint violation:  </p><p class="formulaDsp">
\[
\begin{equation}\label{eq:def-auglagr}
    \begin{aligned}
        \Lagr_\Sigma : \Rn \times \R^m \times \R^m \rightarrow \R : (x, z, y) &amp;\mapsto \Lagr_\Sigma(x, z, y) \\
        &amp;\,\triangleq\, \Lagr(x, z, y) + \tfrac{1}{2} \left\|g(x) - z\right\|^2_\Sigma,
    \end{aligned}
\end{equation}
\]
</p>
<p> where \(\Sigma\) is a symmetric positive definite \(m\times m\) matrix that defines a norm on \(\R^m\), \(\|z\|^2_\Sigma \triangleq z^\top \Sigma z\).</p>
<h2><a class="anchor" id="autotoc_md24"></a>
The augmented Lagrangian method algorithm</h2>
<p>The augmented Lagrangian method for solving Problem \(\eqref{eq:problem-origCD-alm}\) consists of the successive minimization of \(\Lagr_\Sigma\) with respect to the decision variables \(x\) and the slack variables \(z\) (1), after which the Lagrange multipliers \(y\) are updated (2), and the penalty factors \(\Sigma_{ii}\) corresponding to constraints with high violation are increased (3).</p>
<p>The augmented Lagrangian function is used as an exact penalty function for problem \(\eqref{eq:problem-origCD-alm}\), it is equivalent to the shifted quadratic penalty method with shift \(\Sigma^{-1}y\).</p>
<h3>1. Minimization of the augmented Lagrangian</h3>
<p>Using some algebraic manipulations, the augmented Lagrangian defined in \(\eqref{eq:def-auglagr}\) can be expressed as  </p><p class="formulaDsp">
\[
\begin{equation}
    \label{eq:auglagr2}
    \Lagr_\Sigma(x, z, y) = f(x) \;\;+\;\; \frac{1}{2} \Big\Vert g(x) - z + \Sigma^{-1} y \Big\Vert_\Sigma^2
    \;\;-\;\; \frac{1}{2}\Big\Vert y \Big\Vert_{\Sigma^{-1}.}^2
\end{equation}
\]
</p>
<p>At each iteration \(\nu\) of the ALM algorithm, the following minimization problem is solved:  </p><p class="formulaDsp">
\[
\begin{equation}
    \label{eq:alm-step-1-argmin}
    (x^\nu, z^\nu) \;\;=\;\; \underset{x\in C,\; z\in D}{\text{argmin}}\quad \Lagr_{\Sigma^{\nu-1}}(x,\, z;\, y^{\nu-1})
\end{equation}
\]
</p>
<h3>2. Update of the Lagrange multipliers</h3>
<p>The update of the Lagrange multipliers corrects the shift \(\Sigma^{-1} y\) in \(\eqref{eq:auglagr2}\): if the constraint violation \(g(x^\nu) - z^\nu\) is positive, the shift is increased, in an attempt to drive the next iterate towards a smaller constraint violation \(g(x^\nu) - z^\nu\). The following update rule formalizes that idea:  </p><p class="formulaDsp">
\[
\begin{equation}\label{eq:lagr-update-explanation}
    y^\nu \leftarrow y^{\nu-1} + \Sigma^{\nu-1} \left(g(x^\nu) - z^\nu\right)
\end{equation}
\]
</p>
<p> When the constraint violation becomes zero, the Lagrange multipliers are no longer updated.</p>
<p>As the penalty factors \(\Sigma\) tend towards infinity, the shift \(\Sigma^{-1} y\) has to vanish, because in that case, the quadratic penalty method without shifts solves the problem exactly. For \(\Sigma^{-1} y\) to vanish, the Lagrange multipliers must be bounded, which is achieved by the following projection:</p>
<p>Let \(M &gt; 0\) be some large but finite bound.  </p><p class="formulaDsp">
\[
    \begin{gather}
        \underline y_i \triangleq \begin{cases}
            0 &amp; \underline z_i = -\infty \\
            -M &amp; \text{otherwise},
        \end{cases}
        \quad\quad\quad\quad\quad\quad 
        \overline y_i \triangleq \begin{cases}
            0 &amp; \overline z_i = +\infty \\
            +M &amp; \text{otherwise}
        \end{cases} \\[0.66em]
        Y \triangleq [\underline y_1, \overline y_1] \times \dots \times [\underline y_m, \overline y_m]
    \end{gather}
\]
</p>
<p> The result of \(\eqref{eq:lagr-update-explanation}\) is therefore clamped as follows:  </p><p class="formulaDsp">
\[
\begin{equation}\label{eq:lagr-update-explanation-clamp}
    y^\nu \leftarrow \Pi_Y\left(y^{\nu-1} + \Sigma^{\nu-1} \left(g(x^\nu) - z^\nu\right)\right)
\end{equation}
\]
</p>
<h3>3. Update of the penalty factors</h3>
<p>When the penalty factor for the \(i\)-th constraint, \(\Sigma_{ii}\) is increased, minimizing the violation of this constraint becomes more important in \(\eqref{eq:alm-step-1-argmin}\). Therefore, if the constraint violation cannot be reduced by updating the shifts alone, the penalty factors are increased.</p>
<p>Selecting when and by how much each penalty factor should be increased is more of a heuristic. The strategy used here is to compare the violation at the current iterate with the violation at the previous iterate, it is the same strategy as used in <a href="https://arxiv.org/abs/2010.02653">QPALM</a>. Denote the vector of constraint violations as \(e^\nu \triangleq g(x^\nu) - z^\nu\). Let \(\theta \in (0, 1)\). <br  />
 If \(|e^\nu_i| \le \theta |e^{\nu-1}_i|\), meaning that the constraint violation has decreased by at least a factor \(\theta\) compared to the previous iteration, then the penalty factor is not updated. <br  />
 If the constraint violation did not decrease sufficiently, then the penalty factor \(\Sigma_{ii}\) is increased by a factor  </p><p class="formulaDsp">
\[
\begin{equation}\label{eq:multipliers-update-factor}
    \Delta \dfrac{|e^\nu_i|}{\|e^\nu\|_\infty},
\end{equation}
\]
</p>
<p> where \(\Delta &gt; 1\) is a tuning parameter. The violation of each individual constraint is scaled by the maximum violation of all constraints, such that the penalty factors of constraints with a large violation are increased more aggressively. If the factor in \(\eqref{eq:multipliers-update-factor}\) is less than one, the penalty factor is not updated (otherwise it would result in a reduction of the penalty).</p>
<h1><a class="anchor" id="autotoc_md25"></a>
PANOC</h1>
<p>PANOC is an algorithm that solves optimization problems of the form:  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        &amp; \underset{x}{\text{minimize}}
        &amp; &amp; \psi(x) + h(x),
    \end{aligned}
    \label{eq:problem-panoc}
    \tag{P-PANOC}
\end{equation}
\]
</p>
<p> where \(\psi : \Rn \rightarrow \R \) has Lipschitz gradient, and \(h : \Rn \rightarrow \overline \R \) allows efficient computation of the proximal operator.</p>
<p>Recall the inner minimization problem \(\eqref{eq:alm-step-1-argmin}\) in the first step of the ALM algorithm. It can be simplified to:  </p><p class="formulaDsp">
\[
\begin{equation}
    \label{eq:problem-inner}
    \begin{aligned}
        \min_{x\in C,\, z\in D} \Lagr_\Sigma(x, z, y)
        &amp;= -\tfrac{1}{2} \lVert y \rVert_{\Sigma^{-1}}^2
        + \min_{x\in C}\left\{ f(x)
        + \min_{z\in D} \left\{
        \tfrac{1}{2} \left\Vert z - \left(g(x) + \Sigma^{-1} y\right)\right\Vert_\Sigma^2
        \right\}
        \right\} \\
        &amp;= -\tfrac{1}{2} \lVert y \rVert_{\Sigma^{-1}}^2
        + \min_{x\in C}\;\;
        \bigg\{
        \underbrace{
        f(x)
        + \tfrac{1}{2} \text{dist}_\Sigma^2 \left(
        g(x) + \Sigma^{-1}y, \ D
        \right)}_{\triangleq\, \psi_{\Sigma}(x;\,y)}
        \bigg\}
        \end{aligned}
\end{equation}
\]
</p>
<p> Within the PANOC algorithm, the parameters \(y\) and \(\Sigma\) remain constant, and will be omitted from the function names to ease notation:  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        \psi(x) &amp;= f(x)
        + \tfrac{1}{2} \text{dist}_\Sigma^2 \left(
        g(x) + \Sigma^{-1}y, \ D
        \right)
    \end{aligned}
    \label{eq:psi-inner-panoc}
\end{equation}
\]
</p>
<p> The inner problem in \(\eqref{eq:problem-inner}\) has the same minimizers as the following problem that will be solved using the PANOC algorithm:  </p><p class="formulaDsp">
\[
\begin{equation}
    \begin{aligned}
        &amp; \underset{x\in C}{\text{minimize}}
        &amp; &amp; \psi(x),
    \end{aligned}
    \label{eq:problem-inner-panoc}
\end{equation}
\]
</p>
<p> This problem is an instance of problem \(\eqref{eq:problem-panoc}\) where the nonsmooth term \(h\) is the indicator of the set \(C\), \(h(x) = \delta_C(x)\).</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Evaluation</h2>
<p>The following is a list of symbols and formulas that are used in the implementation of the PANOC algorithm.</p>
<p class="formulaDsp">
\[
    \DeclareMathOperator{\prox}{\mathbf{prox}}
    \DeclareMathOperator*{\argmin}{\mathbf{argmin}}
    \DeclareMathOperator{\dist}{\mathbf{dist}}
    \DeclareMathOperator*{\minimize}{\mathbf{minimize}\;\;}

    \begin{aligned}
    y &amp;\in \R^m &amp;\text{Current Lagrange multipliers} \\
    \Sigma &amp;\in \text{diag}(\R^m_{&gt;0}) &amp;\text{Current penalty factor} \\
    x^k &amp;\in \Rn &amp;\text{Current PANOC iterate} \\
    \gamma_k &amp;\in \R_{&gt;0} &amp;\text{Current proximal gradient step size} \\[1em]
    \zeta^k &amp;\triangleq g(x^k) + \Sigma^{-1}y &amp;\text{Shifted constraint value}\\
    \hat{z}^k &amp;\triangleq \Pi_D\left(g(x^k) + \Sigma^{-1}y\right) &amp;\text{Closest feasible value for slack variable } z \\
    &amp;= \Pi_D(\zeta^k) \\
    d^k &amp;\triangleq \zeta^k - \Pi_D(\zeta^k) &amp;\text{How far the shifted constraint value }\zeta \\
    &amp;= \zeta^k - \hat{z}^k  &amp;\text{is from the feasible set}\\
    e^k &amp;\triangleq g(x^k) - \hat z^k &amp;\text{Constraint violation} \\
    \hat{y}^k &amp;\triangleq \Sigma\, d^k &amp;\text{Candidate Lagrange multipliers,}\\
    &amp;= \Sigma\, \left(g(x^k) + \Sigma^{-1}y - \Pi_D\left(g(x^k) + \Sigma^{-1}y\right)\right) &amp;\text{see \eqref{eq:lagr-update-explanation}}\\
    &amp;= y + \Sigma\,\left(g(x^k) - \hat z^k\right) \\
    &amp;= y + \Sigma\, e^k \\[1em]
    \psi(x^k) &amp;= \Lagr_\Sigma(x^k, \hat z^k, y) + \tfrac{1}{2} \lVert y \rVert_{\Sigma^{-1}}^2 &amp;\text{PANOC objective function} \\    
    &amp;= f(x^k) + \tfrac{1}{2} \dist_\Sigma^2\left(g(x^k) + \Sigma^{-1}y,\;D\right) \\
    &amp;= f(x^k) + \tfrac{1}{2} \left\|\left(g(x^k) + \Sigma^{-1}y\right) -\Pi_D\left(g(x^k) + \Sigma^{-1}y\right)\right\|_\Sigma^2 \\
    &amp;= f(x^k) + \tfrac{1}{2} \left\|\zeta^k - \hat{z}^k\right\|_\Sigma^2 \\
    &amp;= f(x^k) + \tfrac{1}{2} \langle d^k, \hat{y}^k \rangle \\[1em]
    \nabla \psi(x^k) &amp;= \nabla f(x^k)
        + \nabla g(x^k)\, \Sigma \left(g(x^k) + \Sigma^{-1}y - \Pi_D(g(x^k) + \Sigma^{-1}y)\right) &amp;\text{Gradient of the objective} \\
    &amp;= \nabla f(x^k) + \nabla g(x^k)\, \Sigma\, \big(\zeta^k - \hat{z}^k\big) \\
    &amp;= \nabla f(x^k) + \nabla g(x^k)\, \hat{y}^k \\
    &amp;= \nabla f(x^k) + \sum_{i=1}^m \hat{y}^k_i\, \nabla g_i(x^k) \\[1em]
    \nabla \hat y^k_i(x^k) &amp;= \Sigma_{ii} \left(1 - \partial \Pi_{D_i}\left(g_i(x^k) + \Sigma^{-1}_{ii} y_i\right) \right)\, \nabla g_i(x^k) \\
    \nabla^2 \psi(x^k) &amp;= \nabla^2 f(x^k) + \sum_{i=1}^m \hat{y}^k_i\, \nabla^2 g_i(x^k) + \sum_{i=1}^m \nabla g_i(x^k)\, \nabla^\top \hat{y}^k_i  &amp;\text{Generalized Hessian of the objective}\\
    &amp;= \nabla^2_{xx} \Lagr(x^k, y) + \sum_{i=1}^m \nabla g_i(x^k)\, \hat\sigma_i\, \nabla g_i(x^k)^\top \\
    \hat\sigma_i &amp;\in \begin{cases}
    \left\{\Sigma_{ii}\right\} &amp; \text{if } g_i(x^k) + \Sigma_{ii}^{-1} y_i \not\in D_i \\
    \left[0, \Sigma_{ii}\right] &amp; \text{if } g_i(x^k) + \Sigma_{ii}^{-1} y_i \in \operatorname{bd} D_i \\
    \left\{0\right\} &amp; \text{if } g_i(x^k) + \Sigma_{ii}^{-1} y_i \in \operatorname{int} D_i \\
    \end{cases}
    \\[1em]
    \hat{x}^k &amp;\triangleq T_{\gamma^k}\left(x^k\right) &amp;\text{Next proximal gradient iterate}\\
    &amp;= \Pi_C\left(x^k - \gamma^k \nabla \psi(x^k)\right) \\
    p^k &amp;\triangleq \hat{x}^k - x^k &amp;\text{Proximal gradient step}\\
    r^k &amp;\triangleq \tfrac{1}{\gamma^k} p^k &amp;\text{Fixed-point residual (FPR)}\\[1em]
    \varphi_{\gamma^k}(x^k) &amp;= \psi(x^k) + h(\hat{x}^k) + \tfrac{1}{2\gamma^k} \lVert \hat{x}^k - x^k \rVert^2 + \nabla\psi(x^k)^\top (\hat{x}^k - x^k) &amp;\text{Forward-backward envelope (FBE)}\\
    &amp;= \psi(x^k) + \tfrac{1}{2\gamma^k} \lVert p^k \rVert^2 + \nabla\psi(x^k)^\top p^k \\[1em]
    q^k &amp;\triangleq H_k r^k &amp;\text{Quasi-Newton step} \\
    x^{k+1} &amp;= x^k + (1-\tau) p^k + \tau q^k &amp;\text{Next PANOC iterate} \\
    \end{aligned}
\]
</p>
<p>Note that many of the intermediate values depend on the value of \(x^k\), it is sometimes easiest to define them as functions:  </p><p class="formulaDsp">
\[
    \begin{aligned}
    \zeta(x) &amp;\triangleq g(x) + \Sigma^{-1}y\\
    \hat{z}(x) &amp;\triangleq \Pi_D\left(g(x) + \Sigma^{-1}y\right)  \\
    &amp;= \Pi_D(\zeta(x)) \\
    d(x) &amp;\triangleq \zeta(x) - \Pi_D(\zeta(x)) \\
    &amp;= \zeta(x) - \hat{z}(x)  \\
    \hat{y}(x) &amp;\triangleq \Sigma\, d(x) \\
    &amp;= \Sigma\, \left(g(x) + \Sigma^{-1}y - \Pi_D\left(g(x) + \Sigma^{-1}y\right)\right)\\
    e(x) &amp;\triangleq g(x) - \hat z(x)
    \end{aligned}
\]
</p>
<p>The result of the PANOC algorithm is the triple \((\hat x^k,\;\hat y(\hat x^k),\;\hat z(\hat x^k))\).</p>
<p>The following graph visualizes the dependencies between the different values used in a PANOC iteration.</p>
<div class="image">
<object type="image/svg+xml" data="expression-dep.gv.svg" style="pointer-events: none;"></object>
</div>
<h1><a class="anchor" id="autotoc_md27"></a>
Structured PANOC</h1>
<p>See <a class="el" href="citelist.html#CITEREF_pas2022alpaqa">[2]</a> for details.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
PANOC-OCP</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
Problem formulation</h2>
<p>Consider the following general formulation of a nonlinear optimal control problem with finite horizon \( N \).  </p><p class="formulaDsp">
\[
\newcommand\U{U}
\newcommand\D{D}
\newcommand\nnu{{n_u}}
\newcommand\nnx{{n_x}}
\newcommand\nny{{n_y}}
\newcommand\xinit{x_\text{init}}
\newcommand\xref{x_\text{r}}
\newcommand\uref{u_\text{r}}
\begin{equation}\label{eq:OCP} \tag{OCP}\hspace{-0.8em}
    \begin{aligned}
        &amp;\minimize_{u,x} &amp;&amp; \sum_{k=0}^{N-1} \ell_k\big(h_k(x^k, u^k)\big) + \ell_N\big(h_N(x^N)\big)\hspace{-0.8em} \\
        &amp;\subjto &amp;&amp; u^k \in \U \\
        &amp;&amp;&amp; C(x^k) \in \D \\
        &amp;&amp;&amp; x^0 = \xinit \\
        &amp;&amp;&amp; x^{k+1} = f(x^k, u^k) \quad\quad (0 \le k \lt N)
    \end{aligned}
\end{equation}
\]
</p>
<p>The function \( f : \R^\nnx \times \R^\nnu \to \R^\nnx \) models the discrete-time, nonlinear dynamics of the system, which starts from an initial state \( \xinit \). The functions \( h_k : \R^\nnx \times \R^\nnu \to \R^{n_h} \) for \( 0 \le k \lt N \) and \( h_N : \R^\nnx \to \R^{n_h^N} \) can be used to represent the (possibly time-varying) output mapping of the system, and the convex functions \( \ell_k : \R^{n_h} \to \R \) and \( \ell_N : \R^{n_h^N} \to \R \) define the stage costs and the terminal cost respectively.</p>
<p>See <a class="el" href="citelist.html#CITEREF_pas2022gaussnewton">[3]</a> for more details. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
